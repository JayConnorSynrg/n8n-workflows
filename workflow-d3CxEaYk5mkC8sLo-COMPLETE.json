{
  "updatedAt": "2026-01-09T18:22:39.628Z",
  "createdAt": "2025-12-27T04:48:10.416Z",
  "id": "d3CxEaYk5mkC8sLo",
  "name": "Teams Voice Bot v3.0 - Agent Orchestrator",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "voice-bot-v3",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "webhook-1",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "position": [
        0,
        304
      ],
      "webhookId": "voice-bot-v3",
      "typeVersion": 2.1
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// CONSOLIDATED: Parse + Extract + Classify + Response Timing + DEDUPLICATION v3\n// ENHANCED: Added is_first_message detection for greeting handling + phonetic bot names\nconst item = $input.item.json;\nconst body = item.body || {};\nconst data = body.data || {};\nconst inner = data.data || {};\nconst words = inner.words || [];\nconst participant = inner.participant || {};\nconst bot = data.bot || {};\n\n// Early exit if no words\nif (!Array.isArray(words) || words.length === 0) {\n  return {\n    json: {\n      route: 'NO_TRANSCRIPT',\n      event_type: body.event || 'unknown',\n      bot_id: bot.id || 'unknown',\n      transcript: '',\n      is_final: false,\n      speaker: 'unknown',\n      speaker_id: null,\n      is_host: false,\n      received_at: Date.now(),\n      intent: 'no_content',\n      should_respond: false,\n      is_addressing_bot: false,\n      is_first_message: false,\n      response_timing: { is_complete_thought: false, response_urgency: 'none' },\n      session_state: { last_orchestrator_cues: '', pending_actions: [], processing_count: 0 },\n      classified_at: new Date().toISOString(),\n      dedup: { is_duplicate: false, reason: 'no_words' }\n    }\n  };\n}\n\nconst transcript = words.map(w => w.text).join(' ').trim();\nconst speaker = participant.name || 'unknown';\nconst bot_id = bot.id || 'unknown';\n\n// === SESSION STATE & DEDUPLICATION v3 ===\nconst staticData = $getWorkflowStaticData('global');\nconst now = Date.now();\n\nif (!staticData.botTranscripts) staticData.botTranscripts = {};\nif (!staticData.botTranscripts[bot_id]) {\n  staticData.botTranscripts[bot_id] = {\n    lastProcessedTranscript: '',\n    lastProcessedTime: 0,\n    processingCount: 0,\n    sessionStartTime: now,\n    lastOrchestratorCues: '',\n    pendingActions: []\n  };\n}\n\nconst botState = staticData.botTranscripts[bot_id];\nconst lastTranscript = botState.lastProcessedTranscript;\nconst timeSinceLastProcess = now - botState.lastProcessedTime;\n\n// First message detection (no prior processing OR > 5 min inactive)\nconst isFirstMessage = botState.processingCount === 0 || timeSinceLastProcess > 300000;\nif (isFirstMessage && timeSinceLastProcess > 300000) {\n  botState.sessionStartTime = now;\n  botState.processingCount = 0;\n  botState.lastOrchestratorCues = '';\n  botState.pendingActions = [];\n}\n\n// Deduplication\nlet isDuplicate = false, isExtension = false, dedupReason = 'new_content';\nif (lastTranscript && timeSinceLastProcess < 15000) {\n  const currentLower = transcript.toLowerCase().trim();\n  const lastLower = lastTranscript.toLowerCase().trim();\n  if (currentLower === lastLower) {\n    isDuplicate = true;\n    dedupReason = 'exact_duplicate';\n  } else if (currentLower.startsWith(lastLower) || lastLower.startsWith(currentLower)) {\n    isExtension = true;\n    dedupReason = currentLower.startsWith(lastLower) ? 'extension_of_previous' : 'subset_of_previous';\n  }\n}\n\n// === RESPONSE TIMING ===\nconst hasEndPunctuation = /[.!?]$/.test(transcript);\nconst wordCount = words.length;\nlet speakingDurationMs = 0;\nif (words.length >= 2) {\n  const f = words[0], l = words[words.length - 1];\n  if (f.start_timestamp?.relative && l.end_timestamp?.relative) {\n    speakingDurationMs = (l.end_timestamp.relative - f.start_timestamp.relative) * 1000;\n  }\n}\n\nconst lowerTranscript = transcript.toLowerCase();\nconst isFromHuman = !['bot', 'assistant'].includes(speaker.toLowerCase());\n\n// PHONETIC bot name detection\nconst botPatterns = [\n  /\\b(synergy|synrg)\\s*bot\\b/i, /\\bsynergy\\b/i, /\\bsynrg\\b/i,\n  /\\bsin\\s*urge\\s*y?\\b/i, /\\bsin\\s*ergy\\b/i, /\\bcin\\s*ergy\\b/i, /\\bsen\\s*ergy\\b/i,\n  /\\bhey\\s+(synergy|synrg|sin\\s*ergy)\\b/i,\n  /\\b(bot|assistant|ai|hey\\s*bot|hello\\s*bot|voice\\s*bot)\\b/i\n];\nconst isAddressingBot = botPatterns.some(p => p.test(lowerTranscript));\n\nconst emailPatterns = /send\\s*(an\\s*)?email|email\\s*to|compose\\s*email|write\\s*(an\\s*)?email/i;\nconst questionPatterns = /\\?$|what|how|when|where|why|can you|could you|tell me|explain/i;\nconst greetingPatterns = /^(hi|hello|hey|good morning|good afternoon|good evening)/i;\nconst commandPatterns = /please|help|need|want|could you|can you|would you/i;\n\n// Complete thought detection (voice-friendly, no punctuation required)\nlet isCompleteThought = false, responseUrgency = 'none';\nif (hasEndPunctuation && wordCount >= 4) {\n  isCompleteThought = true; responseUrgency = 'standard';\n} else if (wordCount >= 10) {\n  isCompleteThought = true; responseUrgency = 'standard';\n} else if (wordCount >= 5 && isAddressingBot) {\n  isCompleteThought = true; responseUrgency = 'immediate';\n} else if (wordCount >= 5 && (emailPatterns.test(lowerTranscript) || commandPatterns.test(lowerTranscript))) {\n  isCompleteThought = true; responseUrgency = 'standard';\n} else if (wordCount < 4) {\n  isCompleteThought = false; responseUrgency = 'wait';\n}\n\nif (isFirstMessage && greetingPatterns.test(lowerTranscript) && wordCount >= 2) {\n  isCompleteThought = true; responseUrgency = 'immediate';\n}\n\nlet route = 'SILENT', intent = 'no_content', shouldRespond = false;\nconst isFinal = isCompleteThought;\n\nif (isDuplicate) {\n  route = 'SILENT'; intent = 'duplicate_skipped';\n} else if (isExtension) {\n  route = 'WAIT_LOG'; intent = 'partial_extension';\n} else if (isFromHuman && isCompleteThought) {\n  const requiresResponse = isAddressingBot || \n    emailPatterns.test(lowerTranscript) || \n    (questionPatterns.test(lowerTranscript) && commandPatterns.test(lowerTranscript)) ||\n    (greetingPatterns.test(lowerTranscript) && isFirstMessage);\n  \n  if (requiresResponse) {\n    route = 'PROCESS'; shouldRespond = true;\n    intent = emailPatterns.test(lowerTranscript) ? 'email_request' :\n             (greetingPatterns.test(lowerTranscript) && isFirstMessage) ? 'first_greeting' :\n             questionPatterns.test(lowerTranscript) ? 'question' :\n             greetingPatterns.test(lowerTranscript) ? 'greeting' :\n             isAddressingBot ? 'addressing_bot' : 'command';\n    botState.lastProcessedTranscript = transcript;\n    botState.lastProcessedTime = now;\n    botState.processingCount++;\n  } else {\n    route = 'LISTEN'; intent = 'general_speech';\n  }\n} else if (!isCompleteThought && transcript.length > 0) {\n  route = 'WAIT_LOG'; intent = 'partial_transcript';\n}\n\nreturn {\n  json: {\n    bot_id, transcript, is_final: isFinal, speaker,\n    speaker_id: participant.id || null, is_host: participant.is_host || false,\n    received_at: Date.now(), event_type: body.event || 'unknown',\n    route, intent, should_respond: shouldRespond,\n    is_addressing_bot: isAddressingBot, is_first_message: isFirstMessage,\n    response_timing: { is_complete_thought: isCompleteThought, has_end_punctuation: hasEndPunctuation, word_count: wordCount, speaking_duration_ms: speakingDurationMs, response_urgency: responseUrgency },\n    session_state: { last_orchestrator_cues: botState.lastOrchestratorCues, pending_actions: botState.pendingActions, processing_count: botState.processingCount, session_start_time: botState.sessionStartTime },\n    dedup: { is_duplicate: isDuplicate, is_extension: isExtension, reason: dedupReason, last_processed: lastTranscript, time_since_last_ms: timeSinceLastProcess, processing_count: botState.processingCount },\n    classified_at: new Date().toISOString()\n  }\n};"
      },
      "id": "process-transcript",
      "name": "Process Transcript",
      "type": "n8n-nodes-base.code",
      "position": [
        208,
        304
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "rule-silent",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "leftValue": "={{ $json.route }}",
                    "rightValue": "SILENT"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "SILENT"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "rule-wait",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "leftValue": "={{ $json.route }}",
                    "rightValue": "WAIT_LOG"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "WAIT_LOG"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "rule-listen",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "leftValue": "={{ $json.route }}",
                    "rightValue": "LISTEN"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "LISTEN"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "rule-process",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "leftValue": "={{ $json.route }}",
                    "rightValue": "PROCESS"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "PROCESS"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "rule-no-transcript",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "leftValue": "={{ $json.route }}",
                    "rightValue": "NO_TRANSCRIPT"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "NO_TRANSCRIPT"
            }
          ]
        },
        "options": {
          "fallbackOutput": "none"
        }
      },
      "id": "route-switch",
      "name": "Route Switch",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        432,
        288
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO transcript_log (bot_id, transcript, speaker, route, intent, is_final, created_at) VALUES ('{{ $json.bot_id }}', '{{ $json.transcript }}', '{{ $json.speaker }}', '{{ $json.route }}', '{{ $json.intent }}', {{ $json.is_final }}, NOW()) RETURNING id",
        "options": {}
      },
      "id": "log-silent-transcript",
      "name": "Log Silent Transcript",
      "type": "n8n-nodes-base.postgres",
      "position": [
        672,
        -80
      ],
      "typeVersion": 2.6,
      "credentials": {
        "postgres": {
          "id": "NI3jbq1U8xPst3j3",
          "name": "MICROSOFT TEAMS AGENT DATTABASE"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const input = $input.item.json;\nreturn {\n  json: {\n    action: 'wait_log',\n    bot_id: input.bot_id,\n    transcript: input.transcript,\n    speaker: input.speaker,\n    intent: input.intent,\n    route: input.route,\n    is_final: input.is_final,\n    logged_at: new Date().toISOString(),\n    message: 'Partial transcript - logged without response'\n  }\n};"
      },
      "id": "wait-log",
      "name": "Wait Log Only",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        672,
        160
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO transcript_log (bot_id, transcript, speaker, route, intent, is_final, created_at) VALUES ('{{ $json.bot_id }}', '{{ $json.transcript }}', '{{ $json.speaker }}', '{{ $json.route }}', '{{ $json.intent }}', {{ $json.is_final }}, NOW()) RETURNING id",
        "options": {}
      },
      "id": "log-wait-transcript",
      "name": "Log Wait Transcript",
      "type": "n8n-nodes-base.postgres",
      "position": [
        880,
        160
      ],
      "typeVersion": 2.6,
      "credentials": {
        "postgres": {
          "id": "NI3jbq1U8xPst3j3",
          "name": "MICROSOFT TEAMS AGENT DATTABASE"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO transcript_log (bot_id, transcript, speaker, route, intent, is_final, created_at) VALUES ('{{ $json.bot_id }}', '{{ $json.transcript }}', '{{ $json.speaker }}', '{{ $json.route }}', '{{ $json.intent }}', {{ $json.is_final }}, NOW()) RETURNING id",
        "options": {}
      },
      "id": "listen-log",
      "name": "Log Listen Transcript",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        672,
        320
      ],
      "credentials": {
        "postgres": {
          "id": "NI3jbq1U8xPst3j3",
          "name": "MICROSOFT TEAMS AGENT DATTABASE"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT transcript_exact, agent_output_raw, tool_calls, classifier_intent, logged_at\nFROM interaction_logs \nWHERE bot_id = '{{ $json.bot_id }}' \nORDER BY logged_at DESC \nLIMIT 4",
        "options": {}
      },
      "id": "load-state-1",
      "name": "Load Bot State",
      "type": "n8n-nodes-base.postgres",
      "position": [
        672,
        496
      ],
      "typeVersion": 2.6,
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "NI3jbq1U8xPst3j3",
          "name": "MICROSOFT TEAMS AGENT DATTABASE"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// BUILD AGENT CONTEXT - v3 with stronger anti-repeat logic\nconst transcript = $('Process Transcript').first().json;\n\n// Load conversation history\nlet historyRows = [];\ntry {\n  historyRows = $('Load Bot State').all().map(item => item.json);\n} catch (e) {\n  historyRows = [];\n}\n\n// Extract recent transcripts and responses\nconst recentInteractions = historyRows.slice(0, 4).map(row => ({\n  userSaid: (row.transcript_exact || '').toLowerCase().trim(),\n  botReplied: row.agent_output_raw || ''\n}));\n\n// Build conversation history for context\nlet conversationHistory = '';\nif (recentInteractions.length > 0) {\n  conversationHistory = '\\n\\n## Recent Conversation History:\\n';\n  recentInteractions.forEach((interaction, i) => {\n    conversationHistory += `${i + 1}. User: \"${interaction.userSaid}\"\\n   You said: \"${interaction.botReplied}\"\\n`;\n  });\n}\n\n// Check for similar recent responses to avoid\nconst recentResponses = recentInteractions.map(i => i.botReplied).filter(r => r);\nconst uniqueResponses = [...new Set(recentResponses)];\n\n// Check if user is continuing same topic\nconst currentLower = transcript.transcript.toLowerCase();\nconst lastUserMessage = recentInteractions[0]?.userSaid || '';\nconst isContinuation = currentLower.includes(lastUserMessage) || lastUserMessage.includes(currentLower);\n\n// Response timing from classifier\nconst timing = transcript.response_timing || {};\nconst urgency = timing.response_urgency || 'standard';\nconst isComplete = timing.is_complete_thought || false;\n\n// Detect if this is an email request that needs an address\nconst needsEmailAddress = /send.*email|email.*to/i.test(currentLower) && \n  !/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/.test(currentLower);\n\n// Check if we already asked for email address\nconst alreadyAskedForEmail = recentResponses.some(r => \n  r.toLowerCase().includes('email address') || \n  r.toLowerCase().includes('what email') ||\n  r.toLowerCase().includes('send that to')\n);\n\n// Build the system prompt with strong anti-repeat logic\nlet responseGuidance = '';\nif (needsEmailAddress && alreadyAskedForEmail) {\n  responseGuidance = `\\n\\n## IMPORTANT: You already asked for the email address!\\nThe user is still talking. They haven't given you an email address yet.\\nWAIT for them to provide an email address. Do NOT ask again.\\nSay something like: \"I'm ready when you have that email address.\" or \"Just let me know the recipient.\"`;\n} else if (isContinuation) {\n  responseGuidance = `\\n\\n## IMPORTANT: User is continuing their previous message.\\nThis appears to be a continuation of what they were saying.\\nDon't repeat your previous response - acknowledge they're still talking or wait for them to finish.`;\n}\n\nconst systemPrompt = `You are a voice assistant in a Microsoft Teams meeting.\n\n## How This Works\nYour text output is AUTOMATICALLY converted to speech and played in the meeting.\nDo NOT describe what you'll say - just say it directly.\n\n## CRITICAL ANTI-REPEAT RULES\n\n**YOUR PREVIOUS RESPONSES (DO NOT SAY THESE AGAIN):**\n${uniqueResponses.map((r, i) => `${i + 1}. \"${r}\"`).join('\\n')}\n\n**If you repeat ANY of the above responses, the user will hear the same thing twice. This is a BAD user experience.**\n${responseGuidance}\n\n## Response Rules\n\nURGENCY: ${urgency.toUpperCase()} | COMPLETE THOUGHT: ${isComplete ? 'YES' : 'NO'}\n\n${urgency === 'wait' || urgency === 'none' ? \n`⚠️ STAY SILENT - ${urgency === 'wait' ? 'incomplete sentence, wait for more' : 'background conversation'}\nOutput nothing. This is correct behavior.` :\n`Respond concisely (1-2 sentences). Your words will be spoken aloud.`}\n\n## Tools Available\n- gmail_agent: Send emails (requires transcript + email_address)\n- think: Internal reasoning (silent, user won't hear)\n\n## Email Workflow\n1. If user asks to send email but no address: Ask for email address ONCE\n2. If you already asked: WAIT for them to provide it\n3. When you have both content and address: Call gmail_agent\n4. Confirm when done: \"Email sent!\"\n${conversationHistory}\n\n## Current Input\nIntent: ${transcript.intent || 'unknown'}\nSpeaker: ${transcript.speaker || 'unknown'}\nMessage #${historyRows.length + 1}\n\nRespond naturally, briefly, and NEVER repeat a previous response verbatim.`;\n\nreturn [{\n  json: {\n    user_input: transcript.transcript,\n    bot_id: transcript.bot_id,\n    is_final: transcript.is_final,\n    intent: transcript.intent,\n    current_state: historyRows[0]?.ai_analysis?.conversation_state || 'IDLE',\n    message_count: historyRows.length + 1,\n    session_id: transcript.bot_id + '_session',\n    received_at: transcript.received_at,\n    response_urgency: urgency,\n    is_complete_thought: isComplete,\n    is_continuation: isContinuation,\n    already_asked_for_email: alreadyAskedForEmail,\n    system_prompt: systemPrompt,\n    chat_input: transcript.transcript\n  }\n}];"
      },
      "id": "build-context-1",
      "name": "Build Agent Context",
      "type": "n8n-nodes-base.code",
      "position": [
        848,
        480
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chat_input }}",
        "options": {
          "systemMessage": "={{ $json.system_prompt }}",
          "maxIterations": 5
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        1024,
        480
      ],
      "id": "6b9b0552-8540-47fa-b65d-d2d46882fc5a",
      "name": "Orchestrator Agent"
    },
    {
      "parameters": {
        "model": "openai/gpt-4o-mini",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        912,
        720
      ],
      "id": "1dc8c729-f513-4140-94f1-db3ddf723700",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "OPPAOWUbmkR2frSd",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "description": "Send emails on behalf of the user. Provide the recipient's email address and what to say in the email.",
        "workflowId": {
          "__rl": true,
          "value": "kL0AP3CkRby6OmVb",
          "mode": "id"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "transcript": "={{ $fromAI('transcript', 'The user request or message content for the email', 'string') }}",
            "email_address": "={{ $fromAI('email_address', 'The recipient email address to send to (REQUIRED)', 'string') }}",
            "context": "={{ {} }}",
            "bot_id": "={{ $('Build Agent Context').first().json.bot_id }}",
            "session_id": "={{ $('Build Agent Context').first().json.session_id }}"
          },
          "schema": [
            {
              "id": "transcript",
              "displayName": "transcript",
              "required": true,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "email_address",
              "displayName": "email_address",
              "required": true,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "context",
              "displayName": "context",
              "required": false,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "object",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "bot_id",
              "displayName": "bot_id",
              "required": true,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": true,
              "defaultMatch": false,
              "canBeUsedToMatch": true,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ]
        }
      },
      "id": "gmail-tool-1",
      "name": "Gmail Agent Tool",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        1376,
        784
      ],
      "typeVersion": 2.2
    },
    {
      "parameters": {},
      "id": "think-tool-1",
      "name": "Think Tool",
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "position": [
        1520,
        768
      ],
      "typeVersion": 1.1
    },
    {
      "parameters": {
        "jsCode": "// Build Immutable Log v2.1 - Enhanced with session_state and is_first_message\nconst agent = $('Orchestrator Agent').first().json;\nconst context = $('Build Agent Context').first().json;\nconst classifier = $('Process Transcript').first().json;\n\nlet ttsSuccess = false, sentenceCount = 0;\nlet ttsMessage = agent.output || '';\n\ntry {\n  const sentenceData = $('Split into Sentences').first();\n  if (sentenceData && sentenceData.json) {\n    sentenceCount = sentenceData.json.total_sentences || 1;\n    ttsSuccess = true;\n  }\n} catch (e) { sentenceCount = 1; }\n\ntry {\n  const sendResults = $('Send Sentence Audio').all();\n  if (sendResults && sendResults.length > 0) {\n    ttsSuccess = sendResults.every(r => !r.json.error);\n  }\n} catch (e) {}\n\nlet toolCalls = [];\ntry {\n  if (agent.intermediateSteps) {\n    toolCalls = agent.intermediateSteps.map(step => ({\n      tool: (step.action && step.action.tool) || 'unknown',\n      input: (step.action && step.action.toolInput) || {},\n      output: step.observation || null\n    }));\n  }\n  if (agent.steps && agent.steps.length > 0) {\n    toolCalls = agent.steps.map(step => ({\n      tool: (step.action && step.action.tool) || 'unknown',\n      input: (step.action && step.action.toolInput) || {},\n      output: step.observation || null\n    }));\n  }\n} catch (e) { toolCalls = []; }\n\ntoolCalls.push({\n  tool: 'chunked_tts',\n  input: { message: ttsMessage, sentence_count: sentenceCount },\n  output: ttsSuccess ? 'Sent ' + sentenceCount + ' audio chunks' : 'TTS failed'\n});\n\n// Update static data with orchestrator cues for next iteration\nconst staticData = $getWorkflowStaticData('global');\nif (staticData.botTranscripts && staticData.botTranscripts[context.bot_id]) {\n  // Store the AI output for next iteration's session_state\n  staticData.botTranscripts[context.bot_id].lastOrchestratorCues = agent.output || '';\n  // Track pending actions from tool calls\n  const pendingTools = toolCalls.filter(tc => \n    tc.tool !== 'chunked_tts' && tc.tool !== 'think' && \n    tc.output && tc.output.includes && tc.output.includes('pending')\n  ).map(tc => tc.tool);\n  staticData.botTranscripts[context.bot_id].pendingActions = pendingTools;\n}\n\nreturn {\n  transcript_exact: context.user_input || '',\n  agent_output_raw: agent.output || '',\n  tool_calls: toolCalls,\n  timestamps: {\n    received_at: context.received_at,\n    processed_at: Date.now(),\n    logged_at: new Date().toISOString()\n  },\n  session_id: context.session_id,\n  bot_id: context.bot_id,\n  classifier_route: classifier.route,\n  classifier_intent: classifier.intent,\n  tts_result: {\n    success: ttsSuccess,\n    audio_sent: ttsSuccess,\n    call_count: sentenceCount,\n    chunked: true,\n    source: 'sentence_loop'\n  },\n  workflow_source: 'orchestrator',\n  error_flags: {\n    agent_error: !agent.output,\n    tts_error: !ttsSuccess\n  },\n  // NEW: Pass session state and first message flag to logging sub-workflow\n  session_state: classifier.session_state || {\n    last_orchestrator_cues: '',\n    pending_actions: [],\n    processing_count: 0\n  },\n  is_first_message: classifier.is_first_message || false\n};"
      },
      "id": "log-1",
      "name": "Build Immutable Log",
      "type": "n8n-nodes-base.code",
      "position": [
        2000,
        528
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "8LX5tt3SkO8GNuLj",
          "mode": "id"
        },
        "options": {}
      },
      "id": "call-logging-agent",
      "name": "Call Logging Agent",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        2208,
        528
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "has-output",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              },
              "leftValue": "={{ $json.output }}",
              "rightValue": ""
            }
          ]
        },
        "options": {}
      },
      "id": "check-output-if",
      "name": "Check Agent Output",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1392,
        496
      ]
    },
    {
      "parameters": {
        "jsCode": "// SENTENCE-LEVEL TTS CHUNKING\n// Split agent output into sentences for progressive audio delivery\nconst agentOutput = $('Orchestrator Agent').first().json.output || '';\nconst botId = $('Build Agent Context').first().json.bot_id;\n\nif (!agentOutput.trim()) {\n  return [{ json: { sentences: [], bot_id: botId, total_sentences: 0, skip_tts: true } }];\n}\n\n// Split by sentence boundaries\n// Matches: . ! ? followed by space or end of string\n// Preserves punctuation with the sentence\nconst sentencePattern = /[^.!?]*[.!?]+(?:\\s|$)/g;\nlet sentences = agentOutput.match(sentencePattern) || [agentOutput];\n\n// Clean up sentences\nsentences = sentences\n  .map(s => s.trim())\n  .filter(s => s.length > 0);\n\n// If no sentences found (no punctuation), treat as single chunk\nif (sentences.length === 0) {\n  sentences = [agentOutput.trim()];\n}\n\n// Return array of items - one per sentence\nconst items = sentences.map((sentence, index) => ({\n  json: {\n    sentence: sentence,\n    sentence_index: index,\n    total_sentences: sentences.length,\n    bot_id: botId,\n    is_first: index === 0,\n    is_last: index === sentences.length - 1,\n    full_output: agentOutput\n  }\n}));\n\nreturn items;"
      },
      "id": "split-sentences",
      "name": "Split into Sentences",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1584,
        384
      ]
    },
    {
      "parameters": {
        "jsCode": "// PARALLEL TTS GENERATION → SEQUENTIAL RECALL.AI DELIVERY\n// v2: Added bot status check before sending\n\nconst items = $input.all();\nif (!items.length) {\n  return [{ json: { success: false, error: 'No sentences to process' } }];\n}\n\nconst bot_id = items[0].json.bot_id;\nconst voice = items[0].json.voice || 'alloy';\n\nconst OPENAI_API_KEY = 'OPENAI_API_KEY_REDACTED';\nconst RECALL_API_KEY = '4f12c2c033fc1f0fe1e4ca2fcd0aad92b547ff43';\n\n// STEP 0: Check bot status first\nlet botActive = false;\nlet botStatus = 'unknown';\ntry {\n  const statusResponse = await this.helpers.httpRequest({\n    method: 'GET',\n    url: `https://us-west-2.recall.ai/api/v1/bot/${bot_id}/`,\n    headers: {\n      'Authorization': `Token ${RECALL_API_KEY}`\n    },\n    returnFullResponse: false\n  });\n  \n  // Check the last status in status_changes array\n  if (statusResponse.status_changes && statusResponse.status_changes.length > 0) {\n    const lastStatus = statusResponse.status_changes[statusResponse.status_changes.length - 1];\n    botStatus = lastStatus.code;\n    // Active states: in_call_recording, in_call_not_recording\n    botActive = ['in_call_recording', 'in_call_not_recording'].includes(botStatus);\n  }\n} catch (error) {\n  console.log(`Bot status check failed: ${error.message}`);\n  botStatus = 'check_failed';\n  botActive = false;\n}\n\nif (!botActive) {\n  return [{\n    json: {\n      ...items[0].json,\n      tts_summary: {\n        total_sentences: items.length,\n        tts_generated: 0,\n        tts_failed: 0,\n        audio_sent: 0,\n        send_failed: 0,\n        send_errors: [],\n        skipped_reason: `Bot not active (status: ${botStatus})`\n      }\n    }\n  }];\n}\n\n// STEP 1: Generate ALL TTS in parallel\nconst ttsPromises = items.map(async (item, index) => {\n  const sentence = item.json.sentence;\n  const sentenceIndex = item.json.sentence_index ?? index;\n  \n  try {\n    const response = await this.helpers.httpRequest({\n      method: 'POST',\n      url: 'https://api.openai.com/v1/audio/speech',\n      headers: {\n        'Authorization': `Bearer ${OPENAI_API_KEY}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        model: 'tts-1',\n        voice: voice,\n        input: sentence,\n        response_format: 'mp3'\n      }),\n      encoding: 'arraybuffer',\n      returnFullResponse: false\n    });\n    \n    const audio_base64 = Buffer.from(response).toString('base64');\n    \n    return {\n      sentenceIndex,\n      sentence,\n      audio_base64,\n      success: true\n    };\n  } catch (error) {\n    return {\n      sentenceIndex,\n      sentence,\n      error: error.message,\n      success: false\n    };\n  }\n});\n\nconst allAudio = await Promise.all(ttsPromises);\nconst failures = allAudio.filter(a => !a.success);\nconst successfulAudio = allAudio.filter(a => a.success);\nsuccessfulAudio.sort((a, b) => a.sentenceIndex - b.sentenceIndex);\n\n// STEP 2: Send to Recall.ai SEQUENTIALLY\nconst sendResults = [];\nfor (const audio of successfulAudio) {\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: `https://us-west-2.recall.ai/api/v1/bot/${bot_id}/output_audio/`,\n      headers: {\n        'Authorization': `Token ${RECALL_API_KEY}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        kind: 'mp3',\n        b64_data: audio.audio_base64\n      }),\n      returnFullResponse: false\n    });\n    \n    sendResults.push({\n      sentenceIndex: audio.sentenceIndex,\n      sent: true\n    });\n  } catch (error) {\n    sendResults.push({\n      sentenceIndex: audio.sentenceIndex,\n      sent: false,\n      error: error.message\n    });\n  }\n}\n\nreturn [{\n  json: {\n    ...items[0].json,\n    tts_summary: {\n      total_sentences: items.length,\n      tts_generated: successfulAudio.length,\n      tts_failed: failures.length,\n      audio_sent: sendResults.filter(r => r.sent).length,\n      send_failed: sendResults.filter(r => !r.sent).length,\n      send_errors: sendResults.filter(r => !r.sent).map(r => r.error),\n      bot_status: botStatus\n    }\n  }\n}];"
      },
      "id": "parallel-tts-send",
      "name": "Parallel TTS & Send",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1808,
        384
      ]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Process Transcript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Transcript": {
      "main": [
        [
          {
            "node": "Route Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Switch": {
      "main": [
        [
          {
            "node": "Log Silent Transcript",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Wait Log Only",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log Listen Transcript",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Load Bot State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait Log Only": {
      "main": [
        [
          {
            "node": "Log Wait Transcript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Agent Context": {
      "main": [
        [
          {
            "node": "Orchestrator Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Orchestrator Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Gmail Agent Tool": {
      "ai_tool": [
        [
          {
            "node": "Orchestrator Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Think Tool": {
      "ai_tool": [
        [
          {
            "node": "Orchestrator Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Build Immutable Log": {
      "main": [
        [
          {
            "node": "Call Logging Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Bot State": {
      "main": [
        [
          {
            "node": "Build Agent Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Orchestrator Agent": {
      "main": [
        [
          {
            "node": "Check Agent Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Agent Output": {
      "main": [
        [
          {
            "node": "Split into Sentences",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Immutable Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split into Sentences": {
      "main": [
        [
          {
            "node": "Parallel TTS & Send",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parallel TTS & Send": {
      "main": [
        [
          {
            "node": "Build Immutable Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "staticData": {
    "global": {
      "botTranscripts": {
        "a1ccaacd-0a69-4e34-adae-c6e9c49306e0": {
          "lastProcessedTranscript": "can you help me send an email synerg",
          "lastProcessedTime": 1767155893875,
          "pendingWords": [],
          "processingLock": false
        },
        "807b681e-6629-4dea-9f20-8e0315da48c9": {
          "lastProcessedTranscript": "",
          "lastProcessedTime": 0,
          "processingCount": 0
        }
      }
    }
  },
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "f09b0654-e194-42da-87d2-4068a3d1b40a",
  "activeVersionId": "f09b0654-e194-42da-87d2-4068a3d1b40a",
  "versionCounter": 341,
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2025-12-27T04:48:10.419Z",
      "createdAt": "2025-12-27T04:48:10.419Z",
      "role": "workflow:owner",
      "workflowId": "d3CxEaYk5mkC8sLo",
      "projectId": "vaRklvnINMqrVVkS",
      "project": {
        "updatedAt": "2025-05-03T20:14:26.988Z",
        "createdAt": "2025-05-03T20:14:24.356Z",
        "id": "vaRklvnINMqrVVkS",
        "name": "Jay Connor <jayconnor@exesyndrome.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "cd6f3efb-1d17-4b28-b2dc-bb38f830be30",
        "projectRelations": [
          {
            "updatedAt": "2025-05-03T20:14:24.357Z",
            "createdAt": "2025-05-03T20:14:24.357Z",
            "userId": "cd6f3efb-1d17-4b28-b2dc-bb38f830be30",
            "projectId": "vaRklvnINMqrVVkS",
            "user": {
              "updatedAt": "2026-01-09T18:09:48.000Z",
              "createdAt": "2025-05-03T20:14:22.867Z",
              "id": "cd6f3efb-1d17-4b28-b2dc-bb38f830be30",
              "email": "jayconnor@exesyndrome.com",
              "firstName": "Jay",
              "lastName": "Connor",
              "personalizationAnswers": null,
              "settings": {
                "userActivated": true,
                "easyAIWorkflowOnboarded": true,
                "firstSuccessfulWorkflowId": "6ALGaDd2bXw27jRn",
                "userActivatedAt": 1747420903813,
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1765406705766
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2026-01-09",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [],
  "activeVersion": {
    "updatedAt": "2026-01-09T18:22:39.629Z",
    "createdAt": "2026-01-09T18:22:39.629Z",
    "versionId": "f09b0654-e194-42da-87d2-4068a3d1b40a",
    "workflowId": "d3CxEaYk5mkC8sLo",
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "voice-bot-v3",
          "responseMode": "onReceived",
          "options": {}
        },
        "id": "webhook-1",
        "name": "Webhook",
        "type": "n8n-nodes-base.webhook",
        "position": [
          0,
          304
        ],
        "webhookId": "voice-bot-v3",
        "typeVersion": 2.1
      },
      {
        "parameters": {
          "mode": "runOnceForEachItem",
          "jsCode": "// CONSOLIDATED: Parse + Extract + Classify + Response Timing + DEDUPLICATION v3\n// ENHANCED: Added is_first_message detection for greeting handling + phonetic bot names\nconst item = $input.item.json;\nconst body = item.body || {};\nconst data = body.data || {};\nconst inner = data.data || {};\nconst words = inner.words || [];\nconst participant = inner.participant || {};\nconst bot = data.bot || {};\n\n// Early exit if no words\nif (!Array.isArray(words) || words.length === 0) {\n  return {\n    json: {\n      route: 'NO_TRANSCRIPT',\n      event_type: body.event || 'unknown',\n      bot_id: bot.id || 'unknown',\n      transcript: '',\n      is_final: false,\n      speaker: 'unknown',\n      speaker_id: null,\n      is_host: false,\n      received_at: Date.now(),\n      intent: 'no_content',\n      should_respond: false,\n      is_addressing_bot: false,\n      is_first_message: false,\n      response_timing: { is_complete_thought: false, response_urgency: 'none' },\n      session_state: { last_orchestrator_cues: '', pending_actions: [], processing_count: 0 },\n      classified_at: new Date().toISOString(),\n      dedup: { is_duplicate: false, reason: 'no_words' }\n    }\n  };\n}\n\nconst transcript = words.map(w => w.text).join(' ').trim();\nconst speaker = participant.name || 'unknown';\nconst bot_id = bot.id || 'unknown';\n\n// === SESSION STATE & DEDUPLICATION v3 ===\nconst staticData = $getWorkflowStaticData('global');\nconst now = Date.now();\n\nif (!staticData.botTranscripts) staticData.botTranscripts = {};\nif (!staticData.botTranscripts[bot_id]) {\n  staticData.botTranscripts[bot_id] = {\n    lastProcessedTranscript: '',\n    lastProcessedTime: 0,\n    processingCount: 0,\n    sessionStartTime: now,\n    lastOrchestratorCues: '',\n    pendingActions: []\n  };\n}\n\nconst botState = staticData.botTranscripts[bot_id];\nconst lastTranscript = botState.lastProcessedTranscript;\nconst timeSinceLastProcess = now - botState.lastProcessedTime;\n\n// First message detection (no prior processing OR > 5 min inactive)\nconst isFirstMessage = botState.processingCount === 0 || timeSinceLastProcess > 300000;\nif (isFirstMessage && timeSinceLastProcess > 300000) {\n  botState.sessionStartTime = now;\n  botState.processingCount = 0;\n  botState.lastOrchestratorCues = '';\n  botState.pendingActions = [];\n}\n\n// Deduplication\nlet isDuplicate = false, isExtension = false, dedupReason = 'new_content';\nif (lastTranscript && timeSinceLastProcess < 15000) {\n  const currentLower = transcript.toLowerCase().trim();\n  const lastLower = lastTranscript.toLowerCase().trim();\n  if (currentLower === lastLower) {\n    isDuplicate = true;\n    dedupReason = 'exact_duplicate';\n  } else if (currentLower.startsWith(lastLower) || lastLower.startsWith(currentLower)) {\n    isExtension = true;\n    dedupReason = currentLower.startsWith(lastLower) ? 'extension_of_previous' : 'subset_of_previous';\n  }\n}\n\n// === RESPONSE TIMING ===\nconst hasEndPunctuation = /[.!?]$/.test(transcript);\nconst wordCount = words.length;\nlet speakingDurationMs = 0;\nif (words.length >= 2) {\n  const f = words[0], l = words[words.length - 1];\n  if (f.start_timestamp?.relative && l.end_timestamp?.relative) {\n    speakingDurationMs = (l.end_timestamp.relative - f.start_timestamp.relative) * 1000;\n  }\n}\n\nconst lowerTranscript = transcript.toLowerCase();\nconst isFromHuman = !['bot', 'assistant'].includes(speaker.toLowerCase());\n\n// PHONETIC bot name detection\nconst botPatterns = [\n  /\\b(synergy|synrg)\\s*bot\\b/i, /\\bsynergy\\b/i, /\\bsynrg\\b/i,\n  /\\bsin\\s*urge\\s*y?\\b/i, /\\bsin\\s*ergy\\b/i, /\\bcin\\s*ergy\\b/i, /\\bsen\\s*ergy\\b/i,\n  /\\bhey\\s+(synergy|synrg|sin\\s*ergy)\\b/i,\n  /\\b(bot|assistant|ai|hey\\s*bot|hello\\s*bot|voice\\s*bot)\\b/i\n];\nconst isAddressingBot = botPatterns.some(p => p.test(lowerTranscript));\n\nconst emailPatterns = /send\\s*(an\\s*)?email|email\\s*to|compose\\s*email|write\\s*(an\\s*)?email/i;\nconst questionPatterns = /\\?$|what|how|when|where|why|can you|could you|tell me|explain/i;\nconst greetingPatterns = /^(hi|hello|hey|good morning|good afternoon|good evening)/i;\nconst commandPatterns = /please|help|need|want|could you|can you|would you/i;\n\n// Complete thought detection (voice-friendly, no punctuation required)\nlet isCompleteThought = false, responseUrgency = 'none';\nif (hasEndPunctuation && wordCount >= 4) {\n  isCompleteThought = true; responseUrgency = 'standard';\n} else if (wordCount >= 10) {\n  isCompleteThought = true; responseUrgency = 'standard';\n} else if (wordCount >= 5 && isAddressingBot) {\n  isCompleteThought = true; responseUrgency = 'immediate';\n} else if (wordCount >= 5 && (emailPatterns.test(lowerTranscript) || commandPatterns.test(lowerTranscript))) {\n  isCompleteThought = true; responseUrgency = 'standard';\n} else if (wordCount < 4) {\n  isCompleteThought = false; responseUrgency = 'wait';\n}\n\nif (isFirstMessage && greetingPatterns.test(lowerTranscript) && wordCount >= 2) {\n  isCompleteThought = true; responseUrgency = 'immediate';\n}\n\nlet route = 'SILENT', intent = 'no_content', shouldRespond = false;\nconst isFinal = isCompleteThought;\n\nif (isDuplicate) {\n  route = 'SILENT'; intent = 'duplicate_skipped';\n} else if (isExtension) {\n  route = 'WAIT_LOG'; intent = 'partial_extension';\n} else if (isFromHuman && isCompleteThought) {\n  const requiresResponse = isAddressingBot || \n    emailPatterns.test(lowerTranscript) || \n    (questionPatterns.test(lowerTranscript) && commandPatterns.test(lowerTranscript)) ||\n    (greetingPatterns.test(lowerTranscript) && isFirstMessage);\n  \n  if (requiresResponse) {\n    route = 'PROCESS'; shouldRespond = true;\n    intent = emailPatterns.test(lowerTranscript) ? 'email_request' :\n             (greetingPatterns.test(lowerTranscript) && isFirstMessage) ? 'first_greeting' :\n             questionPatterns.test(lowerTranscript) ? 'question' :\n             greetingPatterns.test(lowerTranscript) ? 'greeting' :\n             isAddressingBot ? 'addressing_bot' : 'command';\n    botState.lastProcessedTranscript = transcript;\n    botState.lastProcessedTime = now;\n    botState.processingCount++;\n  } else {\n    route = 'LISTEN'; intent = 'general_speech';\n  }\n} else if (!isCompleteThought && transcript.length > 0) {\n  route = 'WAIT_LOG'; intent = 'partial_transcript';\n}\n\nreturn {\n  json: {\n    bot_id, transcript, is_final: isFinal, speaker,\n    speaker_id: participant.id || null, is_host: participant.is_host || false,\n    received_at: Date.now(), event_type: body.event || 'unknown',\n    route, intent, should_respond: shouldRespond,\n    is_addressing_bot: isAddressingBot, is_first_message: isFirstMessage,\n    response_timing: { is_complete_thought: isCompleteThought, has_end_punctuation: hasEndPunctuation, word_count: wordCount, speaking_duration_ms: speakingDurationMs, response_urgency: responseUrgency },\n    session_state: { last_orchestrator_cues: botState.lastOrchestratorCues, pending_actions: botState.pendingActions, processing_count: botState.processingCount, session_start_time: botState.sessionStartTime },\n    dedup: { is_duplicate: isDuplicate, is_extension: isExtension, reason: dedupReason, last_processed: lastTranscript, time_since_last_ms: timeSinceLastProcess, processing_count: botState.processingCount },\n    classified_at: new Date().toISOString()\n  }\n};"
        },
        "id": "process-transcript",
        "name": "Process Transcript",
        "type": "n8n-nodes-base.code",
        "position": [
          208,
          304
        ],
        "typeVersion": 2
      },
      {
        "parameters": {
          "rules": {
            "values": [
              {
                "conditions": {
                  "options": {
                    "version": 2,
                    "leftValue": "",
                    "caseSensitive": true,
                    "typeValidation": "strict"
                  },
                  "combinator": "and",
                  "conditions": [
                    {
                      "id": "rule-silent",
                      "operator": {
                        "type": "string",
                        "operation": "equals"
                      },
                      "leftValue": "={{ $json.route }}",
                      "rightValue": "SILENT"
                    }
                  ]
                },
                "renameOutput": true,
                "outputKey": "SILENT"
              },
              {
                "conditions": {
                  "options": {
                    "version": 2,
                    "leftValue": "",
                    "caseSensitive": true,
                    "typeValidation": "strict"
                  },
                  "combinator": "and",
                  "conditions": [
                    {
                      "id": "rule-wait",
                      "operator": {
                        "type": "string",
                        "operation": "equals"
                      },
                      "leftValue": "={{ $json.route }}",
                      "rightValue": "WAIT_LOG"
                    }
                  ]
                },
                "renameOutput": true,
                "outputKey": "WAIT_LOG"
              },
              {
                "conditions": {
                  "options": {
                    "version": 2,
                    "leftValue": "",
                    "caseSensitive": true,
                    "typeValidation": "strict"
                  },
                  "combinator": "and",
                  "conditions": [
                    {
                      "id": "rule-listen",
                      "operator": {
                        "type": "string",
                        "operation": "equals"
                      },
                      "leftValue": "={{ $json.route }}",
                      "rightValue": "LISTEN"
                    }
                  ]
                },
                "renameOutput": true,
                "outputKey": "LISTEN"
              },
              {
                "conditions": {
                  "options": {
                    "version": 2,
                    "leftValue": "",
                    "caseSensitive": true,
                    "typeValidation": "strict"
                  },
                  "combinator": "and",
                  "conditions": [
                    {
                      "id": "rule-process",
                      "operator": {
                        "type": "string",
                        "operation": "equals"
                      },
                      "leftValue": "={{ $json.route }}",
                      "rightValue": "PROCESS"
                    }
                  ]
                },
                "renameOutput": true,
                "outputKey": "PROCESS"
              },
              {
                "conditions": {
                  "options": {
                    "version": 2,
                    "leftValue": "",
                    "caseSensitive": true,
                    "typeValidation": "strict"
                  },
                  "combinator": "and",
                  "conditions": [
                    {
                      "id": "rule-no-transcript",
                      "operator": {
                        "type": "string",
                        "operation": "equals"
                      },
                      "leftValue": "={{ $json.route }}",
                      "rightValue": "NO_TRANSCRIPT"
                    }
                  ]
                },
                "renameOutput": true,
                "outputKey": "NO_TRANSCRIPT"
              }
            ]
          },
          "options": {
            "fallbackOutput": "none"
          }
        },
        "id": "route-switch",
        "name": "Route Switch",
        "type": "n8n-nodes-base.switch",
        "typeVersion": 3.2,
        "position": [
          432,
          288
        ]
      },
      {
        "parameters": {
          "operation": "executeQuery",
          "query": "=INSERT INTO transcript_log (bot_id, transcript, speaker, route, intent, is_final, created_at) VALUES ('{{ $json.bot_id }}', '{{ $json.transcript }}', '{{ $json.speaker }}', '{{ $json.route }}', '{{ $json.intent }}', {{ $json.is_final }}, NOW()) RETURNING id",
          "options": {}
        },
        "id": "log-silent-transcript",
        "name": "Log Silent Transcript",
        "type": "n8n-nodes-base.postgres",
        "position": [
          672,
          -80
        ],
        "typeVersion": 2.6,
        "credentials": {
          "postgres": {
            "id": "NI3jbq1U8xPst3j3",
            "name": "MICROSOFT TEAMS AGENT DATTABASE"
          }
        }
      },
      {
        "parameters": {
          "mode": "runOnceForEachItem",
          "jsCode": "const input = $input.item.json;\nreturn {\n  json: {\n    action: 'wait_log',\n    bot_id: input.bot_id,\n    transcript: input.transcript,\n    speaker: input.speaker,\n    intent: input.intent,\n    route: input.route,\n    is_final: input.is_final,\n    logged_at: new Date().toISOString(),\n    message: 'Partial transcript - logged without response'\n  }\n};"
        },
        "id": "wait-log",
        "name": "Wait Log Only",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          672,
          160
        ]
      },
      {
        "parameters": {
          "operation": "executeQuery",
          "query": "=INSERT INTO transcript_log (bot_id, transcript, speaker, route, intent, is_final, created_at) VALUES ('{{ $json.bot_id }}', '{{ $json.transcript }}', '{{ $json.speaker }}', '{{ $json.route }}', '{{ $json.intent }}', {{ $json.is_final }}, NOW()) RETURNING id",
          "options": {}
        },
        "id": "log-wait-transcript",
        "name": "Log Wait Transcript",
        "type": "n8n-nodes-base.postgres",
        "position": [
          880,
          160
        ],
        "typeVersion": 2.6,
        "credentials": {
          "postgres": {
            "id": "NI3jbq1U8xPst3j3",
            "name": "MICROSOFT TEAMS AGENT DATTABASE"
          }
        }
      },
      {
        "parameters": {
          "operation": "executeQuery",
          "query": "=INSERT INTO transcript_log (bot_id, transcript, speaker, route, intent, is_final, created_at) VALUES ('{{ $json.bot_id }}', '{{ $json.transcript }}', '{{ $json.speaker }}', '{{ $json.route }}', '{{ $json.intent }}', {{ $json.is_final }}, NOW()) RETURNING id",
          "options": {}
        },
        "id": "listen-log",
        "name": "Log Listen Transcript",
        "type": "n8n-nodes-base.postgres",
        "typeVersion": 2.6,
        "position": [
          672,
          320
        ],
        "credentials": {
          "postgres": {
            "id": "NI3jbq1U8xPst3j3",
            "name": "MICROSOFT TEAMS AGENT DATTABASE"
          }
        }
      },
      {
        "parameters": {
          "operation": "executeQuery",
          "query": "=SELECT transcript_exact, agent_output_raw, tool_calls, classifier_intent, logged_at\nFROM interaction_logs \nWHERE bot_id = '{{ $json.bot_id }}' \nORDER BY logged_at DESC \nLIMIT 4",
          "options": {}
        },
        "id": "load-state-1",
        "name": "Load Bot State",
        "type": "n8n-nodes-base.postgres",
        "position": [
          672,
          496
        ],
        "typeVersion": 2.6,
        "alwaysOutputData": true,
        "credentials": {
          "postgres": {
            "id": "NI3jbq1U8xPst3j3",
            "name": "MICROSOFT TEAMS AGENT DATTABASE"
          }
        },
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "jsCode": "// BUILD AGENT CONTEXT - v3 with stronger anti-repeat logic\nconst transcript = $('Process Transcript').first().json;\n\n// Load conversation history\nlet historyRows = [];\ntry {\n  historyRows = $('Load Bot State').all().map(item => item.json);\n} catch (e) {\n  historyRows = [];\n}\n\n// Extract recent transcripts and responses\nconst recentInteractions = historyRows.slice(0, 4).map(row => ({\n  userSaid: (row.transcript_exact || '').toLowerCase().trim(),\n  botReplied: row.agent_output_raw || ''\n}));\n\n// Build conversation history for context\nlet conversationHistory = '';\nif (recentInteractions.length > 0) {\n  conversationHistory = '\\n\\n## Recent Conversation History:\\n';\n  recentInteractions.forEach((interaction, i) => {\n    conversationHistory += `${i + 1}. User: \"${interaction.userSaid}\"\\n   You said: \"${interaction.botReplied}\"\\n`;\n  });\n}\n\n// Check for similar recent responses to avoid\nconst recentResponses = recentInteractions.map(i => i.botReplied).filter(r => r);\nconst uniqueResponses = [...new Set(recentResponses)];\n\n// Check if user is continuing same topic\nconst currentLower = transcript.transcript.toLowerCase();\nconst lastUserMessage = recentInteractions[0]?.userSaid || '';\nconst isContinuation = currentLower.includes(lastUserMessage) || lastUserMessage.includes(currentLower);\n\n// Response timing from classifier\nconst timing = transcript.response_timing || {};\nconst urgency = timing.response_urgency || 'standard';\nconst isComplete = timing.is_complete_thought || false;\n\n// Detect if this is an email request that needs an address\nconst needsEmailAddress = /send.*email|email.*to/i.test(currentLower) && \n  !/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/.test(currentLower);\n\n// Check if we already asked for email address\nconst alreadyAskedForEmail = recentResponses.some(r => \n  r.toLowerCase().includes('email address') || \n  r.toLowerCase().includes('what email') ||\n  r.toLowerCase().includes('send that to')\n);\n\n// Build the system prompt with strong anti-repeat logic\nlet responseGuidance = '';\nif (needsEmailAddress && alreadyAskedForEmail) {\n  responseGuidance = `\\n\\n## IMPORTANT: You already asked for the email address!\\nThe user is still talking. They haven't given you an email address yet.\\nWAIT for them to provide an email address. Do NOT ask again.\\nSay something like: \"I'm ready when you have that email address.\" or \"Just let me know the recipient.\"`;\n} else if (isContinuation) {\n  responseGuidance = `\\n\\n## IMPORTANT: User is continuing their previous message.\\nThis appears to be a continuation of what they were saying.\\nDon't repeat your previous response - acknowledge they're still talking or wait for them to finish.`;\n}\n\nconst systemPrompt = `You are a voice assistant in a Microsoft Teams meeting.\n\n## How This Works\nYour text output is AUTOMATICALLY converted to speech and played in the meeting.\nDo NOT describe what you'll say - just say it directly.\n\n## CRITICAL ANTI-REPEAT RULES\n\n**YOUR PREVIOUS RESPONSES (DO NOT SAY THESE AGAIN):**\n${uniqueResponses.map((r, i) => `${i + 1}. \"${r}\"`).join('\\n')}\n\n**If you repeat ANY of the above responses, the user will hear the same thing twice. This is a BAD user experience.**\n${responseGuidance}\n\n## Response Rules\n\nURGENCY: ${urgency.toUpperCase()} | COMPLETE THOUGHT: ${isComplete ? 'YES' : 'NO'}\n\n${urgency === 'wait' || urgency === 'none' ? \n`⚠️ STAY SILENT - ${urgency === 'wait' ? 'incomplete sentence, wait for more' : 'background conversation'}\nOutput nothing. This is correct behavior.` :\n`Respond concisely (1-2 sentences). Your words will be spoken aloud.`}\n\n## Tools Available\n- gmail_agent: Send emails (requires transcript + email_address)\n- think: Internal reasoning (silent, user won't hear)\n\n## Email Workflow\n1. If user asks to send email but no address: Ask for email address ONCE\n2. If you already asked: WAIT for them to provide it\n3. When you have both content and address: Call gmail_agent\n4. Confirm when done: \"Email sent!\"\n${conversationHistory}\n\n## Current Input\nIntent: ${transcript.intent || 'unknown'}\nSpeaker: ${transcript.speaker || 'unknown'}\nMessage #${historyRows.length + 1}\n\nRespond naturally, briefly, and NEVER repeat a previous response verbatim.`;\n\nreturn [{\n  json: {\n    user_input: transcript.transcript,\n    bot_id: transcript.bot_id,\n    is_final: transcript.is_final,\n    intent: transcript.intent,\n    current_state: historyRows[0]?.ai_analysis?.conversation_state || 'IDLE',\n    message_count: historyRows.length + 1,\n    session_id: transcript.bot_id + '_session',\n    received_at: transcript.received_at,\n    response_urgency: urgency,\n    is_complete_thought: isComplete,\n    is_continuation: isContinuation,\n    already_asked_for_email: alreadyAskedForEmail,\n    system_prompt: systemPrompt,\n    chat_input: transcript.transcript\n  }\n}];"
        },
        "id": "build-context-1",
        "name": "Build Agent Context",
        "type": "n8n-nodes-base.code",
        "position": [
          848,
          480
        ],
        "typeVersion": 2
      },
      {
        "parameters": {
          "promptType": "define",
          "text": "={{ $json.chat_input }}",
          "options": {
            "systemMessage": "={{ $json.system_prompt }}",
            "maxIterations": 5
          }
        },
        "type": "@n8n/n8n-nodes-langchain.agent",
        "typeVersion": 3,
        "position": [
          1024,
          480
        ],
        "id": "6b9b0552-8540-47fa-b65d-d2d46882fc5a",
        "name": "Orchestrator Agent"
      },
      {
        "parameters": {
          "model": "openai/gpt-4o-mini",
          "options": {}
        },
        "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
        "typeVersion": 1,
        "position": [
          912,
          720
        ],
        "id": "1dc8c729-f513-4140-94f1-db3ddf723700",
        "name": "OpenRouter Chat Model",
        "credentials": {
          "openRouterApi": {
            "id": "OPPAOWUbmkR2frSd",
            "name": "OpenRouter account"
          }
        }
      },
      {
        "parameters": {
          "description": "Send emails on behalf of the user. Provide the recipient's email address and what to say in the email.",
          "workflowId": {
            "__rl": true,
            "value": "kL0AP3CkRby6OmVb",
            "mode": "id"
          },
          "workflowInputs": {
            "mappingMode": "defineBelow",
            "value": {
              "transcript": "={{ $fromAI('transcript', 'The user request or message content for the email', 'string') }}",
              "email_address": "={{ $fromAI('email_address', 'The recipient email address to send to (REQUIRED)', 'string') }}",
              "context": "={{ {} }}",
              "bot_id": "={{ $('Build Agent Context').first().json.bot_id }}",
              "session_id": "={{ $('Build Agent Context').first().json.session_id }}"
            },
            "schema": [
              {
                "id": "transcript",
                "displayName": "transcript",
                "required": true,
                "defaultMatch": false,
                "canBeUsedToMatch": true,
                "display": true,
                "type": "string",
                "readOnly": false,
                "removed": false
              },
              {
                "id": "email_address",
                "displayName": "email_address",
                "required": true,
                "defaultMatch": false,
                "canBeUsedToMatch": true,
                "display": true,
                "type": "string",
                "readOnly": false,
                "removed": false
              },
              {
                "id": "context",
                "displayName": "context",
                "required": false,
                "defaultMatch": false,
                "canBeUsedToMatch": true,
                "display": true,
                "type": "object",
                "readOnly": false,
                "removed": false
              },
              {
                "id": "bot_id",
                "displayName": "bot_id",
                "required": true,
                "defaultMatch": false,
                "canBeUsedToMatch": true,
                "display": true,
                "type": "string",
                "readOnly": false,
                "removed": false
              },
              {
                "id": "session_id",
                "displayName": "session_id",
                "required": true,
                "defaultMatch": false,
                "canBeUsedToMatch": true,
                "display": true,
                "type": "string",
                "readOnly": false,
                "removed": false
              }
            ]
          }
        },
        "id": "gmail-tool-1",
        "name": "Gmail Agent Tool",
        "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
        "position": [
          1376,
          784
        ],
        "typeVersion": 2.2
      },
      {
        "parameters": {},
        "id": "think-tool-1",
        "name": "Think Tool",
        "type": "@n8n/n8n-nodes-langchain.toolThink",
        "position": [
          1520,
          768
        ],
        "typeVersion": 1.1
      },
      {
        "parameters": {
          "jsCode": "// Build Immutable Log v2.1 - Enhanced with session_state and is_first_message\nconst agent = $('Orchestrator Agent').first().json;\nconst context = $('Build Agent Context').first().json;\nconst classifier = $('Process Transcript').first().json;\n\nlet ttsSuccess = false, sentenceCount = 0;\nlet ttsMessage = agent.output || '';\n\ntry {\n  const sentenceData = $('Split into Sentences').first();\n  if (sentenceData && sentenceData.json) {\n    sentenceCount = sentenceData.json.total_sentences || 1;\n    ttsSuccess = true;\n  }\n} catch (e) { sentenceCount = 1; }\n\ntry {\n  const sendResults = $('Send Sentence Audio').all();\n  if (sendResults && sendResults.length > 0) {\n    ttsSuccess = sendResults.every(r => !r.json.error);\n  }\n} catch (e) {}\n\nlet toolCalls = [];\ntry {\n  if (agent.intermediateSteps) {\n    toolCalls = agent.intermediateSteps.map(step => ({\n      tool: (step.action && step.action.tool) || 'unknown',\n      input: (step.action && step.action.toolInput) || {},\n      output: step.observation || null\n    }));\n  }\n  if (agent.steps && agent.steps.length > 0) {\n    toolCalls = agent.steps.map(step => ({\n      tool: (step.action && step.action.tool) || 'unknown',\n      input: (step.action && step.action.toolInput) || {},\n      output: step.observation || null\n    }));\n  }\n} catch (e) { toolCalls = []; }\n\ntoolCalls.push({\n  tool: 'chunked_tts',\n  input: { message: ttsMessage, sentence_count: sentenceCount },\n  output: ttsSuccess ? 'Sent ' + sentenceCount + ' audio chunks' : 'TTS failed'\n});\n\n// Update static data with orchestrator cues for next iteration\nconst staticData = $getWorkflowStaticData('global');\nif (staticData.botTranscripts && staticData.botTranscripts[context.bot_id]) {\n  // Store the AI output for next iteration's session_state\n  staticData.botTranscripts[context.bot_id].lastOrchestratorCues = agent.output || '';\n  // Track pending actions from tool calls\n  const pendingTools = toolCalls.filter(tc => \n    tc.tool !== 'chunked_tts' && tc.tool !== 'think' && \n    tc.output && tc.output.includes && tc.output.includes('pending')\n  ).map(tc => tc.tool);\n  staticData.botTranscripts[context.bot_id].pendingActions = pendingTools;\n}\n\nreturn {\n  transcript_exact: context.user_input || '',\n  agent_output_raw: agent.output || '',\n  tool_calls: toolCalls,\n  timestamps: {\n    received_at: context.received_at,\n    processed_at: Date.now(),\n    logged_at: new Date().toISOString()\n  },\n  session_id: context.session_id,\n  bot_id: context.bot_id,\n  classifier_route: classifier.route,\n  classifier_intent: classifier.intent,\n  tts_result: {\n    success: ttsSuccess,\n    audio_sent: ttsSuccess,\n    call_count: sentenceCount,\n    chunked: true,\n    source: 'sentence_loop'\n  },\n  workflow_source: 'orchestrator',\n  error_flags: {\n    agent_error: !agent.output,\n    tts_error: !ttsSuccess\n  },\n  // NEW: Pass session state and first message flag to logging sub-workflow\n  session_state: classifier.session_state || {\n    last_orchestrator_cues: '',\n    pending_actions: [],\n    processing_count: 0\n  },\n  is_first_message: classifier.is_first_message || false\n};"
        },
        "id": "log-1",
        "name": "Build Immutable Log",
        "type": "n8n-nodes-base.code",
        "position": [
          2000,
          528
        ],
        "typeVersion": 2
      },
      {
        "parameters": {
          "workflowId": {
            "__rl": true,
            "value": "8LX5tt3SkO8GNuLj",
            "mode": "id"
          },
          "options": {}
        },
        "id": "call-logging-agent",
        "name": "Call Logging Agent",
        "type": "n8n-nodes-base.executeWorkflow",
        "typeVersion": 1.2,
        "position": [
          2208,
          528
        ]
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "version": 2,
              "leftValue": "",
              "caseSensitive": true,
              "typeValidation": "strict"
            },
            "combinator": "and",
            "conditions": [
              {
                "id": "has-output",
                "operator": {
                  "type": "string",
                  "operation": "notEmpty"
                },
                "leftValue": "={{ $json.output }}",
                "rightValue": ""
              }
            ]
          },
          "options": {}
        },
        "id": "check-output-if",
        "name": "Check Agent Output",
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.3,
        "position": [
          1392,
          496
        ]
      },
      {
        "parameters": {
          "jsCode": "// SENTENCE-LEVEL TTS CHUNKING\n// Split agent output into sentences for progressive audio delivery\nconst agentOutput = $('Orchestrator Agent').first().json.output || '';\nconst botId = $('Build Agent Context').first().json.bot_id;\n\nif (!agentOutput.trim()) {\n  return [{ json: { sentences: [], bot_id: botId, total_sentences: 0, skip_tts: true } }];\n}\n\n// Split by sentence boundaries\n// Matches: . ! ? followed by space or end of string\n// Preserves punctuation with the sentence\nconst sentencePattern = /[^.!?]*[.!?]+(?:\\s|$)/g;\nlet sentences = agentOutput.match(sentencePattern) || [agentOutput];\n\n// Clean up sentences\nsentences = sentences\n  .map(s => s.trim())\n  .filter(s => s.length > 0);\n\n// If no sentences found (no punctuation), treat as single chunk\nif (sentences.length === 0) {\n  sentences = [agentOutput.trim()];\n}\n\n// Return array of items - one per sentence\nconst items = sentences.map((sentence, index) => ({\n  json: {\n    sentence: sentence,\n    sentence_index: index,\n    total_sentences: sentences.length,\n    bot_id: botId,\n    is_first: index === 0,\n    is_last: index === sentences.length - 1,\n    full_output: agentOutput\n  }\n}));\n\nreturn items;"
        },
        "id": "split-sentences",
        "name": "Split into Sentences",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1584,
          384
        ]
      },
      {
        "parameters": {
          "jsCode": "// PARALLEL TTS GENERATION → SEQUENTIAL RECALL.AI DELIVERY\n// v2: Added bot status check before sending\n\nconst items = $input.all();\nif (!items.length) {\n  return [{ json: { success: false, error: 'No sentences to process' } }];\n}\n\nconst bot_id = items[0].json.bot_id;\nconst voice = items[0].json.voice || 'alloy';\n\nconst OPENAI_API_KEY = 'OPENAI_API_KEY_REDACTED';\nconst RECALL_API_KEY = '4f12c2c033fc1f0fe1e4ca2fcd0aad92b547ff43';\n\n// STEP 0: Check bot status first\nlet botActive = false;\nlet botStatus = 'unknown';\ntry {\n  const statusResponse = await this.helpers.httpRequest({\n    method: 'GET',\n    url: `https://us-west-2.recall.ai/api/v1/bot/${bot_id}/`,\n    headers: {\n      'Authorization': `Token ${RECALL_API_KEY}`\n    },\n    returnFullResponse: false\n  });\n  \n  // Check the last status in status_changes array\n  if (statusResponse.status_changes && statusResponse.status_changes.length > 0) {\n    const lastStatus = statusResponse.status_changes[statusResponse.status_changes.length - 1];\n    botStatus = lastStatus.code;\n    // Active states: in_call_recording, in_call_not_recording\n    botActive = ['in_call_recording', 'in_call_not_recording'].includes(botStatus);\n  }\n} catch (error) {\n  console.log(`Bot status check failed: ${error.message}`);\n  botStatus = 'check_failed';\n  botActive = false;\n}\n\nif (!botActive) {\n  return [{\n    json: {\n      ...items[0].json,\n      tts_summary: {\n        total_sentences: items.length,\n        tts_generated: 0,\n        tts_failed: 0,\n        audio_sent: 0,\n        send_failed: 0,\n        send_errors: [],\n        skipped_reason: `Bot not active (status: ${botStatus})`\n      }\n    }\n  }];\n}\n\n// STEP 1: Generate ALL TTS in parallel\nconst ttsPromises = items.map(async (item, index) => {\n  const sentence = item.json.sentence;\n  const sentenceIndex = item.json.sentence_index ?? index;\n  \n  try {\n    const response = await this.helpers.httpRequest({\n      method: 'POST',\n      url: 'https://api.openai.com/v1/audio/speech',\n      headers: {\n        'Authorization': `Bearer ${OPENAI_API_KEY}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        model: 'tts-1',\n        voice: voice,\n        input: sentence,\n        response_format: 'mp3'\n      }),\n      encoding: 'arraybuffer',\n      returnFullResponse: false\n    });\n    \n    const audio_base64 = Buffer.from(response).toString('base64');\n    \n    return {\n      sentenceIndex,\n      sentence,\n      audio_base64,\n      success: true\n    };\n  } catch (error) {\n    return {\n      sentenceIndex,\n      sentence,\n      error: error.message,\n      success: false\n    };\n  }\n});\n\nconst allAudio = await Promise.all(ttsPromises);\nconst failures = allAudio.filter(a => !a.success);\nconst successfulAudio = allAudio.filter(a => a.success);\nsuccessfulAudio.sort((a, b) => a.sentenceIndex - b.sentenceIndex);\n\n// STEP 2: Send to Recall.ai SEQUENTIALLY\nconst sendResults = [];\nfor (const audio of successfulAudio) {\n  try {\n    await this.helpers.httpRequest({\n      method: 'POST',\n      url: `https://us-west-2.recall.ai/api/v1/bot/${bot_id}/output_audio/`,\n      headers: {\n        'Authorization': `Token ${RECALL_API_KEY}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        kind: 'mp3',\n        b64_data: audio.audio_base64\n      }),\n      returnFullResponse: false\n    });\n    \n    sendResults.push({\n      sentenceIndex: audio.sentenceIndex,\n      sent: true\n    });\n  } catch (error) {\n    sendResults.push({\n      sentenceIndex: audio.sentenceIndex,\n      sent: false,\n      error: error.message\n    });\n  }\n}\n\nreturn [{\n  json: {\n    ...items[0].json,\n    tts_summary: {\n      total_sentences: items.length,\n      tts_generated: successfulAudio.length,\n      tts_failed: failures.length,\n      audio_sent: sendResults.filter(r => r.sent).length,\n      send_failed: sendResults.filter(r => !r.sent).length,\n      send_errors: sendResults.filter(r => !r.sent).map(r => r.error),\n      bot_status: botStatus\n    }\n  }\n}];"
        },
        "id": "parallel-tts-send",
        "name": "Parallel TTS & Send",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1808,
          384
        ]
      }
    ],
    "connections": {
      "Webhook": {
        "main": [
          [
            {
              "node": "Process Transcript",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Process Transcript": {
        "main": [
          [
            {
              "node": "Route Switch",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Route Switch": {
        "main": [
          [
            {
              "node": "Log Silent Transcript",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Wait Log Only",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Log Listen Transcript",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Load Bot State",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Wait Log Only": {
        "main": [
          [
            {
              "node": "Log Wait Transcript",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Build Agent Context": {
        "main": [
          [
            {
              "node": "Orchestrator Agent",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "OpenRouter Chat Model": {
        "ai_languageModel": [
          [
            {
              "node": "Orchestrator Agent",
              "type": "ai_languageModel",
              "index": 0
            }
          ]
        ]
      },
      "Gmail Agent Tool": {
        "ai_tool": [
          [
            {
              "node": "Orchestrator Agent",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Think Tool": {
        "ai_tool": [
          [
            {
              "node": "Orchestrator Agent",
              "type": "ai_tool",
              "index": 0
            }
          ]
        ]
      },
      "Build Immutable Log": {
        "main": [
          [
            {
              "node": "Call Logging Agent",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Load Bot State": {
        "main": [
          [
            {
              "node": "Build Agent Context",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Orchestrator Agent": {
        "main": [
          [
            {
              "node": "Check Agent Output",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check Agent Output": {
        "main": [
          [
            {
              "node": "Split into Sentences",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Build Immutable Log",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Split into Sentences": {
        "main": [
          [
            {
              "node": "Parallel TTS & Send",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Parallel TTS & Send": {
        "main": [
          [
            {
              "node": "Build Immutable Log",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Jay Connor",
    "name": null,
    "description": null,
    "autosaved": false,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-01-09T18:22:39.846Z",
        "id": 226,
        "workflowId": "d3CxEaYk5mkC8sLo",
        "versionId": "f09b0654-e194-42da-87d2-4068a3d1b40a",
        "event": "activated",
        "userId": "cd6f3efb-1d17-4b28-b2dc-bb38f830be30"
      }
    ]
  }
}
